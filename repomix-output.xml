This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: tmp/, *.log
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
assignment/
  current_lesson.md
public/
  index.html
  styles.css
src/
  .python-version
  extract_markdown.py
  htmlnode.py
  main.py
  markdown_blocks.py
  pyproject.toml
  test_extract_markdown.py
  test_htmlnode.py
  test_markdown_blocks.py
  test_textnode.py
  textnode.py
.gitignore
main.sh
test.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="assignment/current_lesson.md">
# Current Project I'm trying to achieve

Build a Static Site Generator

Let's build a static site generator from scratch!

Check out this live demo of what you'll build in this course! But you won't just build this site, you'll build the tool that builds this site. It's pretty meta. You'll also deploy yours to a live URL on the internet, just like mine.
What Is a Static Site Generator?

A static site generator takes raw content files (like Markdown and images) and turns them into a static website (a mix of HTML and CSS files).

Static sites are very popular in the real world for blogs and other content-heavy websites because they're lightning-fast, secure, and easy to host. For example, the Boot.dev Blog is a production-level static site generated with Hugo.
Static vs. Dynamic Sites

A static site is what it sounds like... static. The content is always the same. Users can not:

    Upload files
    Log in
    Leave comments
    Save preferences

You would need a dynamic site for that stuff, which is usually powered by a database and a custom web server. Static sites are great for:

    Blogs
    Portfolios
    Landing pages
    Documentation

Assignment

We'll be using the Boot.dev CLI to run and submit the CLI tests for some of the lessons in this project. Make sure you have it installed.

Run and submit the CLI tests.

The tests just ensure that the CLI is installed and configured correctly.

# Current Lesson/Assignment of Project

Block to HTML

I'm going to give you quite a few steps to do with a bit less guidance. I think you're a beautiful peacock and are ready for it.

Assignment

Create a new function called def markdown_to_html_node(markdown): that converts a full markdown document into a single parent HTMLNode. That one parent HTMLNode should (obviously) contain many child HTMLNode objects representing the nested elements.

FYI: I created an additional 8 helper functions to keep my code neat and easy to understand, because there's a lot of logic necessary for markdown_to_html_node. I don't want to give you my exact functions because I want you to do this from scratch. However, I'll give you the basic order of operations:

    Split the markdown into blocks (you already have a function for this)
    Loop over each block:
        Determine the type of block (you already have a function for this)
        Based on the type of block, create a new HTMLNode with the proper data
        Assign the proper child HTMLNode objects to the block node. I created a shared text_to_children(text) function that works for all block types. It takes a string of text and returns a list of HTMLNodes that represent the inline markdown using previously created functions (think TextNode -> HTMLNode).
        The "code" block is a bit of a special case: it should not do any inline markdown parsing of its children. I didn't use my text_to_children function for this block type, I manually made a TextNode and used text_node_to_html_node.
    Make all the block nodes children under a single parent HTML node (which should just be a div) and return it.
    Create unit tests. Here are two to get you started:

def test_paragraphs(self):
md = """
This is **bolded** paragraph
text in a p
tag here

This is another paragraph with _italic_ text and `code` here

"""

    node = markdown_to_html_node(md)
    html = node.to_html()
    self.assertEqual(
        html,
        "<div><p>This is <b>bolded</b> paragraph text in a p tag here</p><p>This is another paragraph with <i>italic</i> text and <code>code</code> here</p></div>",
    )

def test_codeblock(self):
md = """

```
This is text that _should_ remain
the **same** even with inline stuff
```

"""

    node = markdown_to_html_node(md)
    html = node.to_html()
    self.assertEqual(
        html,
        "<div><pre><code>This is text that _should_ remain\nthe **same** even with inline stuff\n</code></pre></div>",
    )

Run and submit the CLI tests from the root of the project.

Tips

    Quote blocks should be surrounded by a <blockquote> tag.
    Unordered list blocks should be surrounded by a <ul> tag, and each list item should be surrounded by a <li> tag.
    Ordered list blocks should be surrounded by a <ol> tag, and each list item should be surrounded by a <li> tag.
    Code blocks should be surrounded by a <code> tag nested inside a <pre> tag.
    Headings should be surrounded by a <h1> to <h6> tag, depending on the number of # characters.
    Paragraphs should be surrounded by a <p> tag.
</file>

<file path="src/test_markdown_blocks.py">
import unittest
from markdown_blocks import markdown_to_html_node


class TestMarkdownBlocks(unittest.TestCase):
    def test_paragraphs(self):
        md = """
This is **bolded** paragraph
text in a p
tag here

This is another paragraph with _italic_ text and `code` here

"""

        node = markdown_to_html_node(md)
        html = node.to_html()
        print(f"\n\nThe html for paragraph: {html}")
        self.assertEqual(
            html,
            "<div><p>This is <b>bolded</b> paragraph text in a p tag here</p><p>This is another paragraph with <i>italic</i> text and <code>code</code> here</p></div>",
        )

    def test_codeblock(self):
        md = """
```
This is text that _should_ remain
the **same** even with inline stuff
```
"""

        node = markdown_to_html_node(md)
        html = node.to_html()
        print(f"\n\nThe html for codeblock: {html}")
        self.assertEqual(
            html,
            "<div><pre><code>This is text that _should_ remain\nthe **same** even with inline stuff\n</code></pre></div>",
        )
</file>

<file path="public/index.html">
<html>
  <head>
    <title>Why Frontend Development Sucks</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body>
    <h1>Front-end Development is the Worst</h1>
    <p>
      Look, front-end development is for script kiddies and soydevs who can't
      handle the real programming. I mean, it's just a bunch of divs and spans,
      right? And css??? It's like, "Oh, I want this to be red, but not thaaaaat
      red." What a joke.
    </p>
    <p>
      Real programmers code, not silly markup languages. They code on Arch
      Linux, not macOS, and certainly not Windows. They use Vim, not VS Code.
      They use C, not HTML. Come to the
      <a href="https://www.boot.dev">backend</a>, where the real programming
      happens.
    </p>
  </body>
</html>
</file>

<file path="public/styles.css">
body {
  font-family: Arial, sans-serif;
  line-height: 1.6;
  background-color: #1f1f23;
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
}
h1 {
  color: #ffffff;
  margin-bottom: 20px;
}
p {
  color: #999999;
  margin-bottom: 20px;
}
a {
  color: #6568ff;
}
</file>

<file path="src/.python-version">
3.13
</file>

<file path="src/main.py">
from textnode import TextNode
from textnode import TextType


def main():
    new_text_node = TextNode(
        "This is some anchor text", TextType.LINK, "https://boot.dev"
    )
    print(new_text_node)


if __name__ == "__main__":
    main()
</file>

<file path="src/pyproject.toml">
[project]
name = "src"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.13"
dependencies = []
</file>

<file path="main.sh">
python3 src/main.py
</file>

<file path="test.sh">
python3 -m unittest discover -s src
</file>

<file path=".gitignore">
__pycache__/
assignment/
</file>

<file path="src/extract_markdown.py">
import re
from textnode import TextNode, TextType


def text_to_textnodes(text):
    text_node = TextNode(text, TextType.TEXT)
    new_list_of_nodes = split_nodes_link(
        split_nodes_image(
            split_nodes_delimiter(
                split_nodes_delimiter(
                    split_nodes_delimiter([text_node], "**", TextType.BOLD),
                    "_",
                    TextType.ITALIC,
                ),
                "`",
                TextType.CODE,
            )
        )
    )
    return new_list_of_nodes


def extract_markdown_images(text):
    matches = re.findall(r"!\[(.*?)\]\((.*?)\)", text)
    return matches


def extract_markdown_links(text):
    matches = re.findall(r"\[(.*?)\]\((.*?)\)", text)
    return matches


def split_nodes_delimiter(old_nodes, delimiter, text_type):
    new_nodes = []
    for node in old_nodes:
        if node.text_type is not TextType.TEXT:
            new_nodes.append(node)
            continue
        split_text_list = node.text.split(delimiter)
        if len(split_text_list) % 2 == 0:
            raise Exception("Invalid Markdown syntax: missing closing delimiter")
        for index, string in enumerate(split_text_list):
            if index % 2 == 0:
                new_nodes.append(TextNode(string, TextType.TEXT))
            elif string == "":
                continue
            else:
                new_nodes.append(TextNode(string, text_type))

    return new_nodes


def split_nodes_image(old_nodes):
    new_nodes = []
    for node in old_nodes:
        if node.text_type is not TextType.TEXT:
            new_nodes.append(node)
            continue

        after = node.text
        while True:
            images = extract_markdown_images(after)
            if len(images) == 0:
                if after:
                    new_nodes.append(TextNode(after, TextType.TEXT))
                break
            image_alt, image_link = images[0]
            section = after.split(f"![{image_alt}]({image_link})", 1)
            if len(section) != 2:
                raise Exception(
                    "Invalid markdown syntax: image section not properly closed"
                )
            before = section[0]
            if before:
                new_nodes.append(TextNode(before, TextType.TEXT))
            new_nodes.append(TextNode(image_alt, TextType.IMAGE, image_link))
            after = section[1]
    return new_nodes


def split_nodes_link(old_nodes):
    new_nodes = []
    for node in old_nodes:
        if node.text_type is not TextType.TEXT:
            new_nodes.append(node)
            continue

        after = node.text
        while True:
            links = extract_markdown_links(after)
            if len(links) == 0:
                if after:
                    new_nodes.append(TextNode(after, TextType.TEXT))
                break
            link_name, actual_link = links[0]
            section = after.split(f"[{link_name}]({actual_link})", 1)
            if len(section) != 2:
                raise Exception(
                    "Invalid markdown syntax: link section not properly closed"
                )
            before = section[0]
            if before:
                new_nodes.append(TextNode(before, TextType.TEXT))
            new_nodes.append(TextNode(link_name, TextType.LINK, actual_link))
            after = section[1]
    return new_nodes
</file>

<file path="src/test_textnode.py">
import unittest

from textnode import TextNode, TextType
from extract_markdown import text_to_textnodes


class TestTextNode(unittest.TestCase):
    def test_eq(self):
        node = TextNode("This is a text node", TextType.BOLD)
        node2 = TextNode("This is a text node", TextType.BOLD)
        self.assertEqual(node, node2)
        node3 = TextNode("This is a bad node", TextType.ITALIC)
        node4 = TextNode("This is a good node", TextType.ITALIC)
        self.assertNotEqual(node3, node4)
        node5 = TextNode("bold node", TextType.BOLD)
        node6 = TextNode("link", TextType.LINK)
        self.assertNotEqual(node5, node6)
        node7 = TextNode("This should not work", TextType.CODE)

    def test_text_to_textnodes(self):
        heavily_nested = "This is **text** with an _italic_ word and a `code block` and an ![obi wan image](https://i.imgur.com/fJRm4Vk.jpeg) and a [link](https://boot.dev)"
        heavily_nested_result = text_to_textnodes(heavily_nested)
        self.assertListEqual(
            [
                TextNode("This is ", TextType.TEXT),
                TextNode("text", TextType.BOLD),
                TextNode(" with an ", TextType.TEXT),
                TextNode("italic", TextType.ITALIC),
                TextNode(" word and a ", TextType.TEXT),
                TextNode("code block", TextType.CODE),
                TextNode(" and an ", TextType.TEXT),
                TextNode(
                    "obi wan image", TextType.IMAGE, "https://i.imgur.com/fJRm4Vk.jpeg"
                ),
                TextNode(" and a ", TextType.TEXT),
                TextNode("link", TextType.LINK, "https://boot.dev"),
            ],
            heavily_nested_result,
        )

    def test_actually_nested_string(self):

        actually_nested = "This is an **_italic line_ inside of a bolded line** with link to [therapy](www.calmi.so) for good measure."
        actually_nested_result = text_to_textnodes(actually_nested)
        self.assertListEqual(
            [
                TextNode("This is an ", TextType.TEXT),
                TextNode("_italic line_ inside of a bolded line", TextType.BOLD),
                TextNode(" with link to ", TextType.TEXT),
                TextNode("therapy", TextType.LINK, "www.calmi.so"),
                TextNode(" for good measure.", TextType.TEXT),
            ],
            actually_nested_result,
        )

    def test_text(self):
        node = TextNode("This is a text node", TextType.TEXT)
        html_node = node.text_node_to_html_node()
        self.assertEqual(html_node.tag, None)
        self.assertEqual(html_node.value, "This is a text node")

    def test_text_invalid_type(self):
        node = TextNode("This is a text that should fail", "text")
        with self.assertRaises(Exception):
            node.text_node_to_html_node()


if __name__ == "__main__":
    unittest.main()
</file>

<file path="src/markdown_blocks.py">
from enum import Enum
from htmlnode import HTMLNode, LeafNode, ParentNode
from textnode import TextNode, TextType


class BlockType(Enum):
    PARAGRAPH = "paragraph"
    HEADING = "heading"
    CODE = "code"
    QUOTE = "quote"
    OLIST = "ordered_list"
    ULIST = "unordered_list"


def markdown_to_blocks(markdown):
    list_markdown = markdown.split("\n\n")
    new_list = [item.strip() for item in list_markdown if item != ""]
    return new_list


def block_to_block_type(block):
    lines = block.split("\n")
    if block.startswith(("# ", "## ", "### ", "#### ", "##### ", "###### ")):
        return BlockType.HEADING
    if len(lines) > 1 and lines[0].startswith("```") and lines[-1].startswith("```"):
        return BlockType.CODE
    if block.startswith(">"):
        for line in lines:
            if not line.startswith(">"):
                return BlockType.PARAGRAPH
        return BlockType.QUOTE
    if block.startswith("- "):
        for line in lines:
            if not line.startswith("-"):
                return BlockType.PARAGRAPH
        return BlockType.ULIST
    if block.startswith("1. "):
        i = 1
        for line in lines:
            if not line.startswith(f"{i}. "):
                return BlockType.PARAGRAPH
            i += 1
        return BlockType.OLIST
    return BlockType.PARAGRAPH


def markdown_to_html_node(markdown):
    blocked_markdown = markdown_to_blocks(markdown)
    # print(f"Blocked Markdown: {blocked_markdown}")
    blocked_nodes = []
    for block in blocked_markdown:
        type_of_block = block_to_block_type(block)
        list_items = block.split("\n")
        # print(f"Block:\n{block}")
        # print(f"Block Type: {type_of_block}")
        # print(f"List Items: {list_items}")
        if type_of_block == BlockType.QUOTE:
            stripped_list = [item.lstrip("> ").strip() for item in list_items]
            stripped_block = "\n".join(stripped_list)
            quote_node = LeafNode("blockquote", stripped_block)
            blocked_nodes.append(quote_node)
            # print(new_html_node.to_html())
        if type_of_block == BlockType.HEADING:
            heading_count = 0
            for char in block:
                if char == "#":
                    heading_count += 1
                else:
                    break
            stripped_list = [
                item.lstrip("#" * heading_count + " ").strip() for item in list_items
            ]
            stripped_block = "\n".join(stripped_list)
            heading_node = LeafNode(f"h{heading_count}", stripped_block)
            blocked_nodes.append(heading_node)
            # print(new_html_node.to_html())
        if type_of_block == BlockType.PARAGRAPH:
            block = block.replace("\n", " ")
            children = text_to_children(block)
            paragraph_node = ParentNode("p", children)
            blocked_nodes.append(paragraph_node)
            # print(new_html_node.to_html())
        if type_of_block == BlockType.CODE:
            code_content = "\n".join(list_items[1:-1])
            code_content += "\n"
            text_code_node = TextNode(code_content, TextType.CODE)
            text_code_html_node = text_code_node.text_node_to_html_node()
            # code_node = LeafNode("code", code_content)
            pre_node = ParentNode("pre", children=[text_code_html_node])
            blocked_nodes.append(pre_node)
            # print(pre_node.to_html())
        if type_of_block == BlockType.ULIST:
            li_nodes = [
                LeafNode("li", item.lstrip("- ").strip()) for item in list_items
            ]
            ul_node = ParentNode("ul", children=li_nodes)
            blocked_nodes.append(ul_node)
            # print(ul_node.to_html())
        if type_of_block == BlockType.OLIST:
            i = 1
            li_nodes = []
            for item in list_items:
                li_nodes.append(LeafNode("li", item.lstrip(f"{i}. ").strip()))
                i += 1
            # li_nodes = [
            #     LeafNode("li", item.lstrip("- ").strip()) for item in list_items
            # ]
            ol_node = ParentNode("ol", children=li_nodes)
            blocked_nodes.append(ol_node)
            # print(ol_node.to_html())
    div_node = ParentNode("div", blocked_nodes)
    return div_node


def text_to_children(text):
    import re

    children = []
    patterns = [
        (r"\*\*(.*?)\*\*", TextType.BOLD),
        (r"_(.*?)_", TextType.ITALIC),
        (r"`(.*?)`", TextType.CODE),
    ]
    pos = 0
    while pos < len(text):
        match = None
        for pattern, text_type in patterns:
            match = re.search(pattern, text[pos:])
            if match:
                if match.start() > 0:
                    children.append(
                        TextNode(text[pos : pos + match.start()], TextType.TEXT)
                    )
                children.append(TextNode(match.group(1), text_type))
                pos += match.end()
                break
        if not match:
            children.append(TextNode(text[pos:], TextType.TEXT))
            break
    return [child.text_node_to_html_node() for child in children]


# markdown = """
# - Item 1
# - Item 2
# - Item 3
# """
# markdown = """
# ```
# This is text that _should_ remain
# the **same** even with inline stuff
# ```
# """
# nodes = markdown_to_html_node(markdown)
# print(nodes.to_html())
</file>

<file path="src/test_extract_markdown.py">
import unittest

from extract_markdown import (
    extract_markdown_images,
    extract_markdown_links,
)
from markdown_blocks import BlockType, block_to_block_type, markdown_to_blocks
from extract_markdown import split_nodes_delimiter, split_nodes_image, split_nodes_link
from textnode import TextNode, TextType


class TestExtractMarkdown(unittest.TestCase):
    def test_split_nodes(self):
        code_node = TextNode("This is a text with a `code block` word", TextType.TEXT)
        italic_node = TextNode("This is _an italic word_.", TextType.TEXT)
        italic_nested_bold_node = TextNode(
            "This is an _italic and **bold** word_.", TextType.TEXT
        )
        bold_node = TextNode("This is a **bold** node", TextType.TEXT)

        self.assertEqual(
            split_nodes_delimiter(
                old_nodes=[code_node], delimiter="`", text_type=TextType.CODE
            ),
            [
                TextNode("This is a text with a ", TextType.TEXT),
                TextNode("code block", TextType.CODE),
                TextNode(" word", TextType.TEXT),
            ],
        )

        self.assertEqual(
            split_nodes_delimiter(
                old_nodes=[italic_node], delimiter="_", text_type=TextType.ITALIC
            ),
            [
                TextNode("This is ", TextType.TEXT),
                TextNode("an italic word", TextType.ITALIC),
                TextNode(".", TextType.TEXT),
            ],
        )

        self.assertEqual(
            split_nodes_delimiter(
                old_nodes=[italic_nested_bold_node],
                delimiter="_",
                text_type=TextType.ITALIC,
            ),
            [
                TextNode("This is an ", TextType.TEXT),
                TextNode("italic and **bold** word", TextType.ITALIC),
                TextNode(".", TextType.TEXT),
            ],
        )

        self.assertEqual(
            split_nodes_delimiter(
                old_nodes=[bold_node], delimiter="**", text_type=TextType.BOLD
            ),
            [
                TextNode("This is a ", TextType.TEXT),
                TextNode("bold", TextType.BOLD),
                TextNode(" node", TextType.TEXT),
            ],
        )

    def test_split_images(self):
        node = TextNode(
            "This is text with an ![image](https://i.imgur.com/zjjcJKZ.png) and another ![second image](https://i.imgur.com/3elNhQu.png)",
            TextType.TEXT,
        )
        new_nodes = split_nodes_image([node])
        self.assertListEqual(
            [
                TextNode("This is text with an ", TextType.TEXT),
                TextNode("image", TextType.IMAGE, "https://i.imgur.com/zjjcJKZ.png"),
                TextNode(" and another ", TextType.TEXT),
                TextNode(
                    "second image", TextType.IMAGE, "https://i.imgur.com/3elNhQu.png"
                ),
            ],
            new_nodes,
        )

    def test_split_links(self):
        node = TextNode(
            "This is text with a [link](https://boot.dev) and another [neovim](www.gogoogleitnoob.com)",
            TextType.TEXT,
        )

        new_nodes = split_nodes_link([node])
        self.assertListEqual(
            [
                TextNode("This is text with a ", TextType.TEXT),
                TextNode("link", TextType.LINK, "https://boot.dev"),
                TextNode(" and another ", TextType.TEXT),
                TextNode("neovim", TextType.LINK, "www.gogoogleitnoob.com"),
            ],
            new_nodes,
        )

    def test_extract_markdown_images(self):
        matches = extract_markdown_images(
            "This is text with an ![image](https://i.imgur.com/zjjcJKZ.png)"
        )
        self.assertListEqual([("image", "https://i.imgur.com/zjjcJKZ.png")], matches)

    def test_extract_markdown_links(self):
        matches = extract_markdown_links(
            "This is a text with a link to [google](www.google.com) and a link to [Github](www.github.com)."
        )
        self.assertListEqual(
            [("google", "www.google.com"), ("Github", "www.github.com")], matches
        )

    def test_markdown_to_blocks(self):
        md = """
This is **bolded** paragraph

This is another paragraph with _italic_ text and `code` here
This is the same paragraph on a new line

- This is a list
- with items
"""
        blocks = markdown_to_blocks(md)
        self.assertEqual(
            blocks,
            [
                "This is **bolded** paragraph",
                "This is another paragraph with _italic_ text and `code` here\nThis is the same paragraph on a new line",
                "- This is a list\n- with items",
            ],
        )

    def test_markdown_to_blocks_2(self):
        md = """


This is an _italic_ line.
This is a line next to italic line.

Testing double new line.
"""
        blocks = markdown_to_blocks(md)
        self.assertEqual(
            blocks,
            [
                "This is an _italic_ line.\nThis is a line next to italic line.",
                "Testing double new line.",
            ],
        )

    def test_block_to_block_types(self):
        block = "# heading"
        self.assertEqual(block_to_block_type(block), BlockType.HEADING)
        block = "```\ncode\n```"
        self.assertEqual(block_to_block_type(block), BlockType.CODE)
        block = "> quote\n> more quote"
        self.assertEqual(block_to_block_type(block), BlockType.QUOTE)
        block = "- list\n- items"
        self.assertEqual(block_to_block_type(block), BlockType.ULIST)
        block = "1. list\n2. items"
        self.assertEqual(block_to_block_type(block), BlockType.OLIST)
        block = "paragraph"
        self.assertEqual(block_to_block_type(block), BlockType.PARAGRAPH)
</file>

<file path="src/test_htmlnode.py">
import unittest
from htmlnode import HTMLNode, LeafNode, ParentNode


class TestHTMLNode(unittest.TestCase):
    def test_to_html_props(self):
        node = HTMLNode(
            "div",
            "Hello, world!",
            None,
            {"class": "greeting", "href": "https://boot.dev"},
        )
        self.assertEqual(
            node.props_to_html(),
            'class="greeting" href="https://boot.dev"',
        )

    def test_values(self):
        node = HTMLNode(
            "div",
            "I wish I could read",
        )
        self.assertEqual(
            node.tag,
            "div",
        )
        self.assertEqual(
            node.value,
            "I wish I could read",
        )
        self.assertEqual(
            node.children,
            None,
        )
        self.assertEqual(
            node.props,
            None,
        )

    def test_repr(self):
        node = HTMLNode(
            "p",
            "What a strange world",
            None,
            {"class": "primary"},
        )
        self.assertEqual(
            node.__repr__(),
            "HTMLNode(p, What a strange world, children: None, {'class': 'primary'})",
        )

    def test_leaf_to_html_p(self):
        node = LeafNode("p", "Hello, world!")
        self.assertEqual(node.to_html(), "<p>Hello, world!</p>")

    def test_leaf_to_html_a(self):
        node = LeafNode("a", "Click me!", {"href": "https://www.google.com"})
        self.assertEqual(
            node.to_html(),
            '<a href="https://www.google.com">Click me!</a>',
        )

    def test_leaf_to_html_no_tag(self):
        node = LeafNode(None, "Hello, world!")
        self.assertEqual(node.to_html(), "Hello, world!")

    def test_to_html_with_children(self):
        child_node = LeafNode("span", "child")
        parent_node = ParentNode("div", [child_node])
        self.assertEqual(parent_node.to_html(), "<div><span>child</span></div>")

    def test_to_html_with_grandchildren(self):
        grandchild_node = LeafNode("b", "grandchild")
        child_node = ParentNode("span", [grandchild_node])
        parent_node = ParentNode("div", [child_node])
        self.assertEqual(
            parent_node.to_html(),
            "<div><span><b>grandchild</b></span></div>",
        )

    def test_to_html_many_children(self):
        node = ParentNode(
            "p",
            [
                LeafNode("b", "Bold text"),
                LeafNode(None, "Normal text"),
                LeafNode("i", "italic text"),
                LeafNode(None, "Normal text"),
            ],
        )
        self.assertEqual(
            node.to_html(),
            "<p><b>Bold text</b>Normal text<i>italic text</i>Normal text</p>",
        )

    def test_headings(self):
        node = ParentNode(
            "h2",
            [
                LeafNode("b", "Bold text"),
                LeafNode(None, "Normal text"),
                LeafNode("i", "italic text"),
                LeafNode(None, "Normal text"),
            ],
        )
        self.assertEqual(
            node.to_html(),
            "<h2><b>Bold text</b>Normal text<i>italic text</i>Normal text</h2>",
        )

    def test_leaf_to_html_p(self):
        node = LeafNode("p", "Hello, world!")
        self.assertEqual(node.to_html(), "<p>Hello, world!</p>")

        node2 = LeafNode("a", "Click me!", {"href": "https://www.google.com"})
        self.assertEqual(
            node2.to_html(), '<a href="https://www.google.com">Click me!</a>'
        )

    def test_print_children(self):
        node = ParentNode(
            "p",
            [
                LeafNode("b", "Bold text"),
                LeafNode(None, "Normal text"),
                LeafNode("i", "italic text"),
                LeafNode(None, "Normal text"),
            ],
        )

    def test_to_html_with_children(self):
        child_node = LeafNode("span", "child")
        parent_node = ParentNode("div", [child_node])
        self.assertEqual(parent_node.to_html(), "<div><span>child</span></div>")

    def test_to_html_with_grandchildren(self):
        grandchild_node = LeafNode("b", "grandchild")
        child_node = ParentNode("span", [grandchild_node])
        parent_node = ParentNode("div", [child_node])
        self.assertEqual(
            parent_node.to_html(),
            "<div><span><b>grandchild</b></span></div>",
        )

    def test_to_html_errors(self):
        no_child_node = ParentNode("p", children=None)
        child_nodes = [LeafNode("b", "Boldtext"), LeafNode("li", "Alist")]
        no_tag_node = ParentNode(tag=None, children=child_nodes)

        with self.assertRaises(ValueError):
            no_child_node.to_html()

        with self.assertRaises(ValueError):
            no_tag_node.to_html()
</file>

<file path="src/textnode.py">
from enum import Enum

from htmlnode import LeafNode


class TextType(Enum):
    TEXT = "text"
    BOLD = "bold"
    ITALIC = "italic"
    CODE = "code"
    LINK = "link"
    IMAGE = "image"


class TextNode:
    def __init__(self, text, text_type, url=None):
        self.text = text
        self.text_type = text_type
        self.url = url

    def __eq__(self, other):
        return (
            self.text == other.text
            and self.text_type == other.text_type
            and self.url == other.url
        )

    def __repr__(self):
        return f"TextNode{self.text, self.text_type.value, self.url}"

    def text_node_to_html_node(self):
        if self.text_type not in TextType:
            raise Exception("Invalid Text Type")

        # STRINGS ARE NOT ENUM!!!
        if self.text_type == TextType.TEXT:
            return LeafNode(tag=None, value=self.text)
        if self.text_type == TextType.BOLD:
            return LeafNode(tag="b", value=self.text)
        if self.text_type == TextType.ITALIC:
            return LeafNode(tag="i", value=self.text)
        if self.text_type == TextType.CODE:
            return LeafNode(tag="code", value=self.text)
        if self.text_type == TextType.LINK:
            return LeafNode(tag="a", value=self.text, props={"href": self.url})
        if self.text_type == TextType.IMAGE:
            return LeafNode(
                tag="img", value="", props={"src": self.url, "alt": self.text}
            )

        raise Exception("Unknown error occurred")
</file>

<file path="src/htmlnode.py">
class HTMLNode:
    def __init__(self, tag=None, value=None, children=None, props=None):
        self.tag = tag
        self.value = value
        self.children = children
        self.props = props

    def to_html(self):
        raise NotImplementedError("to_html method not implemented")

    def props_to_html(self):
        if not self.props:
            return ""
        return " ".join(f'{key}="{value}"' for key, value in self.props.items())

    def __repr__(self):
        return f"HTMLNode({self.tag}, {self.value}, children: {self.children}, {self.props})"


class LeafNode(HTMLNode):
    def __init__(self, tag, value, props=None):
        super().__init__(tag=tag, value=value, props=props)

    def to_html(self):
        if not self.value:
            raise ValueError("All leaf nodes must have a value")

        if not self.tag:
            return self.value

        if self.props == None:
            return f"<{self.tag}>{self.value}</{self.tag}>"
        return f"<{self.tag} {super().props_to_html()}>{self.value}</{self.tag}>"


class ParentNode(HTMLNode):
    def __init__(self, tag, children, props=None):
        super().__init__(tag=tag, children=children, props=props)

    def to_html(self):
        if self.tag == None:
            raise ValueError("Parent node must have a tag")

        if self.children == None:
            raise ValueError("There are no children")

        list_of_children = ""
        for child in self.children:
            list_of_children += child.to_html()
        return f"<{self.tag}>{list_of_children}</{self.tag}>"
</file>

</files>
